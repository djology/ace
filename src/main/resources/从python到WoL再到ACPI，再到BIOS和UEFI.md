将一切串联起来的起因，是python的远程开机，涉及WoL支持，WoL由ACPI定义，而ACPI存在在BIOS和UEFI中


### BIOS引导和UEFI引导的区别

在X86生态圈十分强势的微软，自己负责操作系统开发，**跳过品牌直接服务最终用户**，甚至不经允许直接升级操作系统，闹出不少风波。强势也带来了副作用，它要直接面对数千数万种千奇百怪的硬件产品，如何才能用一个软件安装包服务于这么多种设备呢？**必须要一个软件抽象层封装这些硬件差别！**

这就引出了BIOS和UEFI的最主要的功能：**初始化硬件和提供硬件的软件抽象**

* ARM体系也要初始化具体主板相关硬件如GPIO和内存等，这些一般在BSP中完成。与X86体系不同之处在于这些硬件完全定制化，初始化的时候就**预先**知道有哪些设备，Solder Down了哪个品牌的哪种内存颗粒，到时候就照方抓药，初始化一大堆寄存器而已。X86系统配置情况在开机时候是不知道的，需要**探测**（Probe）、**Training**(内存和PCIe)和**枚举**（PCIe等等即插即用设备），相对较复杂。
* BIOS和UEFI提供了整个主板、包括主板上外插的设备的软件抽象。通过探测、Training和枚举，BIOS就有了系统所有硬件的信息。它通过几组详细定义好的接口，把这些信息抽象后传递给操作系统，这些信息包括SMBIOS（专栏稍后介绍）、ACPI表（ACPI与UEFI），内存映射表（E820或者UEFI运行时）等等。通过这层映射，才能做到做到操作系统完全不改而能够适配到所有机型和硬件。

在某种程度上来讲，BIOS和UEFI是将操作系统BSP部分单独封装后下放到主板或者BIOS提供商来完成。这在过去带来了巨大的好处，WinXP、Win7现在还可以运行在更新的电脑硬件上，新的硬件只要自己更改一下就行了，兼容性是ARM体系所不能比拟的。当然割裂的生态圈也带来了用户感受的千差万别，这也受到广泛诟病。各自为政也窒息了创新，带来了同质化。为此，Intel越俎代庖，提出了变形本等等概念；而微软更直接出了Surface，似乎要与过去的小伙伴争食。其实这些都是不得已而为之，今后的发展还需要拭目以待。

arm社区最近为了进入x86的传统优势领域，也开始接受uefi，不过一般只在服务器领域。个别厂商为了支持Windows而在平板等设备支持uefi，某厂商在手机上也要引入uefi。不过这些只是支流，并且他们并不把自己叫做BIOS，而叫做Bootloader。

答案就隐藏在上面一节“BIOS、UEFI的目的”中。UEFI扫除了传统BIOS割裂的生态，打通了PC固件之间的鸿沟，并提供统一的接口给操作系统，而不关心操作系统是什么；它能够更好的完成PC固件的终极目的：**初始化硬件**和**提供硬件的软件抽象**，和**启动操作系统**。如果说有什么东西帮助UEFI打败了传统BIOS，那这些东西就是：**标准接口、开放统一和开源了**。

传统BIOS来自于IBM，之后就进入战国时代，激烈的商战让接口统一成为了不可能做到的事，只有在面对微软这个大用户的时候，才勉强提供了“**兼容**”的基于软中断的接口。它封闭、神秘和充满各种不清不楚的预设和祖传代码，在调试PCI的ROM时要小心各种rom之间互相踩，各种只有老师傅才知道的神奇“诀窍”。要写个驱动，让它在各个BIOS厂商那里都能跑，简直成为了一件不可能完成的任务。

UEFI由Intel推动，在一开始就将标准公开，拉上了微软这个PC界的霸主，强势统一了江湖。在近20年的深耕下，统一了固件启动阶段基础框架Spec：PI Spec与操作系统的接口Spec：UEFI Spec，并将抽象硬件的原语性Spec: ACPI Spec也拉入这个大家庭，都变成UEFI Forum的一份子。


### ACPI的诞生

ACPI(Advanced Configuration and Power Interface, 高级配置及电源管理)

在ACPI诞生前，高级电源管理(APM, Advanced Power Management）将电源管理几乎完全交给BIOS，呆板而限制很多，这让微软十分不爽，它希望在电源管理和硬件配置上能有更多的自主权，这也是合理的，谁比操作系统更懂现在用户在干什么呢？

1997年由英特尔、微软、东芝公司共同提出、制定了ACPI 1.0规范。ACPI，顾名思义，就是配置硬件和管理电源的规范。2000年8月康柏和凤凰科技加入，推出 ACPI 2.0规格。2004年9月惠普取代康柏，推出 ACPI 3.0规格。2009年6月16日則推出 ACPI 4.0规格。2011年11月23日推出ACPI 5.0规格。由于ACPI技术正被多个操作系统和处理器架构采用，该规格的管理模式需要与时俱进。2013年10月，**ACPI的推广者们一致同意将ACPI的属有归到UEFI论坛**。从那以后新的ACPI规格将由UEFI论坛制定。最新的规范是ACPI 6.1，大家可以在[Welcome to Unified Extensible Firmware Interface Forum](https://uefi.org/)上下载到最新的版本。

ACPI可以实现的功能包括：
1. **系统电源管理**（System power management）
2. **设备电源管理**（Device power management）
3. **处理器电源管理**（Processor power management）
4. **设备和处理器性能管理**（Device and processor performance management）
5. **配置/即插即用**（Configuration/Plug and Play）
6. **系统事件**（System Event）
7. **电池管理**（Battery management）
8. **温度管理**（Thermal management）
9. **嵌入式控制器**（Embedded Controller）
10. **SMBus控制器**（SMBus Controller）

**ACPI VS APM**

如前面提到的，ACPI取代了APM。这主要归咎于APM将电源管理归于BIOS，OS无从插手，而且其只有电源管理的能力而没有配置的功能（ACPI里的Configuration）。有趣的是APM也是微软和Intel发明的，那是在1992年，他们为了支持那时候才开始火热的IBM兼容机，才加上了电源管理模块。可是计划赶不上变化，才没过几年就不得不提出新的规范。从APM到ACPI的转化使得OS可以全面掌控各个电源模式的转化，并提供了配置功能。

**ACPI VS FDT/DT**

对于ARM和PowerPC世界的人来说，FDT（Flattened Device Tree）/DT（Device Tree）已经占据统治地位很久了。它的诞生源于Linus对于ARM各种SOC与Linux kernel driver强耦合性的一次大爆发（说是 pain in the ass??!）。从此DT的被设计出来了，ARM的耦合性得到了一定的缓解。那时ARM控制着嵌入式和手机世界，X86统治着PC和服务器，曲径分明，井水不犯河水，而ACPI和FDT也相安无事。和平没有持续很久，在X86试图进入手机领域时，ARM也试图进入PC和服务器，大战爆发了。ARM世界的FDT在新战场受到了残酷的抵抗，PC和服务器的玩家们不喜欢FDT，他们希望用一套工具集（toolchain）能同时解决两家问题，他们提出的理由也很有道理：FDT没有ACPI灵活！确实，FDT虽然在提供各种表单方面近似于ACPI，却缺少AML/ASL这样的灵活性。结局是ARM世界宣布在PC和服务器领域全面淘汰FDT，换用ACPI，而在嵌入式系统继续使用FDT。这也是合理的，毕竟嵌入式系统不需要这么多的灵活性，而迁移的代价是巨大的。另一方面，ACPI却随着X86进入嵌入式领域而在X86嵌入式领域生根发芽。

**ACPI　VS　UEFI???**

有人也许会说ACPI提供了OS可用的硬件抽象和接口（method），UEFI也提供了抽象和接口，是不是也有冲突？其实两者面向的方面不同，ACPI主要是从硬件抽象的角度来抽象硬件，UEFI是从软件一致方向定义规范。这也是他们不但没有替代关系，反而从ACPI 5.0 开始ACPI并入UEFI论坛管理的原因。需要指出的是ACPI和UEFI没有绑定关系，ACPI可以在uboot上实现，而UEFI也可以报告DT，但他们一起工作起来会更加顺畅。

### WoL的原理和陷阱

从Intel和IBM在1997年公布标准以来，现在几乎所有的主板都支持网络开机。经过合适的设置，我们可以在局域网或者广域网上开启另一台电脑，甚至用手机开启电脑！但这条路上充满荆棘，我们一起来看看它的原理和都有哪些陷阱。

**网络开机原理**

网络开机叫做Wake-on-LAN，缩写是WoL。过程很简单，即通过发送一组特殊格式的网络封包（Magic Packet）给某个MAC地址的电脑，让该电脑从睡眠模式甚至是关机模式苏醒，即从ACPI的Sx(S3，S4，S5)模式返回S0运行模式。Sx的定义见
1. **固件**
   固件需要保证网络设备和网口（Phy）的电源在Sx的情况下保持供电，以用来监听网络中的Magic Packet。这通常都是通过写一组主板芯片组的寄存器来实现的。
2. **Magic Packet**
   这组特殊封包通常被发送的该机器的UDP端口7和9。如果网卡在Sx的状态收到了这组封包，它就知道有人要开机，它会通过PME#或者其他方式唤醒电脑。

